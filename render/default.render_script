local lighting_state = require "main.lighting_state"
local update_constants
--
-- message constants
--
local MSG_CLEAR_COLOR =         hash("clear_color")
local MSG_WINDOW_RESIZED =      hash("window_resized")
local MSG_SET_VIEW_PROJ =       hash("set_view_projection")
local MSG_SET_CAMERA_PROJ =     hash("use_camera_projection")
local MSG_USE_STRETCH_PROJ =    hash("use_stretch_projection")
local MSG_USE_FIXED_PROJ =      hash("use_fixed_projection")
local MSG_USE_FIXED_FIT_PROJ =  hash("use_fixed_fit_projection")

local DEFAULT_NEAR = -1
local DEFAULT_FAR =   1
local DEFAULT_ZOOM =  1

--
-- projection that centers content with maintained aspect ratio and optional zoom
--
local function get_fixed_projection(camera, state)
    camera.zoom = camera.zoom or DEFAULT_ZOOM
    local projected_width = state.window_width / camera.zoom
    local projected_height = state.window_height / camera.zoom
    local left = -(projected_width - state.width) / 2
    local bottom = -(projected_height - state.height) / 2
    local right = left + projected_width
    local top = bottom + projected_height
    return vmath.matrix4_orthographic(left, right, bottom, top, camera.near, camera.far)
end
--
-- projection that centers and fits content with maintained aspect ratio
--
local function get_fixed_fit_projection(camera, state)
    camera.zoom = math.min(state.window_width / state.width, state.window_height / state.height)
    return get_fixed_projection(camera, state)
end
--
-- projection that stretches content
--
local function get_stretch_projection(camera, state)
    return vmath.matrix4_orthographic(0, state.width, 0, state.height, camera.near, camera.far)
end
--
-- projection for gui
--
local function get_gui_projection(camera, state)
    return vmath.matrix4_orthographic(0, state.window_width, 0, state.window_height, camera.near, camera.far)
end

local function update_clear_color(state, color)
    if color then
        state.clear_buffers[graphics.BUFFER_TYPE_COLOR0_BIT] = color
    end
end

local function update_camera(camera, state)
    camera.proj = camera.projection_fn(camera, state)
    camera.frustum.frustum = camera.proj * camera.view
end

local function update_state(state)
    state.window_width = render.get_window_width()
    state.window_height = render.get_window_height()
    state.valid = state.window_width > 0 and state.window_height > 0
    if not state.valid then
        return false
    end
    -- Make sure state updated only once when resize window
    if state.window_width == state.prev_window_width and state.window_height == state.prev_window_height then
        return true
    end
    state.prev_window_width = state.window_width
    state.prev_window_height = state.window_height
    state.width = render.get_width()
    state.height = render.get_height()
    for _, camera in pairs(state.cameras) do
        update_camera(camera, state)
    end
    return true
end

local function init_camera(camera, projection_fn, near, far, zoom)
    camera.view = vmath.matrix4()
    camera.near = near == nil and DEFAULT_NEAR or near
    camera.far = far == nil and DEFAULT_FAR or far
    camera.zoom = zoom == nil and DEFAULT_ZOOM or zoom
    camera.projection_fn = projection_fn
end

local function create_predicates(...)
    local arg = {...}
    local predicates = {}
    for _, predicate_name in pairs(arg) do
        predicates[predicate_name] = render.predicate({predicate_name})
    end
    return predicates
end

local function create_camera(state, name, is_main_camera)
    local camera = {}
    camera.frustum = {}
    state.cameras[name] = camera
    if is_main_camera then
        state.main_camera = camera
    end
    return camera
end

local function create_state()
    local state = {}
    local color = vmath.vector4(0, 0, 0, 0)
    color.x = sys.get_config_number("render.clear_color_red", 0)
    color.y = sys.get_config_number("render.clear_color_green", 0)
    color.z = sys.get_config_number("render.clear_color_blue", 0)
    color.w = sys.get_config_number("render.clear_color_alpha", 0)
    -- state.clear_buffers = {
    --     [graphics.BUFFER_TYPE_COLOR0_BIT] = color,
    --     [graphics.BUFFER_TYPE_DEPTH_BIT] = 1,
    --     [graphics.BUFFER_TYPE_STENCIL_BIT] = 0
    -- }
    state.clear_buffers = {
        [render.BUFFER_COLOR_BIT] = color,
        [render.BUFFER_DEPTH_BIT] = 1,
        [render.BUFFER_STENCIL_BIT] = 0
    }
    state.cameras = {}
    return state
end

function init(self)
    self.predicates = create_predicates("tile", "gui", "particle", "model", "debug_text", "screen")

    -- default is stretch projection. copy from builtins and change for different projection
    -- or send a message to the render script to change projection:
    -- msg.post("@render:", "use_stretch_projection", { near = -1, far = 1 })
    -- msg.post("@render:", "use_fixed_projection", { near = -1, far = 1, zoom = 2 })
    -- msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })

    local state = create_state()
    self.state = state
    local camera_world = create_camera(state, "camera_world", true)
    init_camera(camera_world, get_stretch_projection)
    local camera_gui = create_camera(state, "camera_gui")
    init_camera(camera_gui, get_gui_projection)
    update_state(state)

    self.constants = render.constant_buffer()
    update_constants(self.constants)

    -- Creating the RT in a render script:
    local color_params = {
        format = render.FORMAT_RGBA,
        width  = render.get_window_width(),
        height = render.get_window_height(),
        -- flags  = render.TEXTURE_BIT -- this will create the buffer as a texture
    }
    local position_params = {
        format = render.FORMAT_RGBA32F,
        width  = render.get_window_width(),
        height = render.get_window_height(),
        -- flags  = render.TEXTURE_BIT -- this will create the buffer as a texture
    }
    local depth_params = {
        format = render.FORMAT_DEPTH,
        width  = render.get_window_width(),
        height = render.get_window_height(),
        flags  = render.TEXTURE_BIT -- this will create the buffer as a texture
    }

    self.render_target = render.render_target(
        "render_target",
        {
            [render.BUFFER_COLOR0_BIT] = color_params, -- color
            [render.BUFFER_COLOR1_BIT] = color_params, -- normals
            [render.BUFFER_COLOR2_BIT] = position_params, -- positions
            [render.BUFFER_DEPTH_BIT]  = depth_params, -- depth
        }
    )
    self.ssao_target = render.render_target(
        "ssao_target",
        {
            [render.BUFFER_COLOR0_BIT] = color_params, -- color
            [render.BUFFER_DEPTH_BIT]  = depth_params, -- depth
        }
    )
end

local i = vmath.matrix4()
local screen_proj = vmath.matrix4_orthographic(-.5, .5, -.5, .5, -1, 1)
local render_options = {}
local ssao_options = {}
function update(self)
    local state = self.state
    if not state.valid then
        if not update_state(state) then
            return
        end
    end

    update_constants(self.constants)

    local predicates = self.predicates

    render.set_render_target(self.render_target)
    -- clear screen buffers
    --
    -- turn on depth_mask before `render.clear()` to clear it as well
    render.set_depth_mask(true)
    render.set_stencil_mask(0xff)
    render.clear(state.clear_buffers)

    -- setup camera view and projection
    --
    local camera_world = state.cameras.camera_world
    render.set_viewport(0, 0, state.window_width, state.window_height)
    render.set_view(camera_world.view)
    render.set_projection(camera_world.proj)

    -- set states used for all the world predicates
    render.set_blend_func(render.BLEND_SRC_ALPHA, render.BLEND_ONE_MINUS_SRC_ALPHA)
    render.enable_state(render.STATE_DEPTH_TEST)

    -- render `model` predicate for default 3D material
    --
    render.enable_state(render.STATE_CULL_FACE)
    render_options.constants = self.constants
    render_options.frustum = camera_world.frustum.frustum
    render.draw(predicates.model, render_options)
    render.set_depth_mask(false)
    render.disable_state(render.STATE_CULL_FACE)

    -- render the other components: sprites, tilemaps, particles etc
    --
    render.enable_state(render.STATE_BLEND)
    render.draw(predicates.tile, camera_world.frustum)
    render.draw(predicates.particle, camera_world.frustum)
    render.disable_state(render.STATE_DEPTH_TEST)

    render.draw_debug3d()

    render.set_render_target(render.RENDER_TARGET_DEFAULT)
    render.clear(state.clear_buffers)
    render.set_view(i)
    render.set_projection(screen_proj)
    render.enable_material("screen_material")
    -- render.enable_texture("render_sampler", self.render_target, render.BUFFER_COLOR0_BIT)
    render.enable_texture("render_sampler", self.render_target, render.BUFFER_COLOR1_BIT)
    -- render.enable_texture("render_sampler", self.render_target, render.BUFFER_DEPTH_BIT)
    render.draw(predicates.screen)
    render.disable_texture("render_sampler")
    render.disable_material()

    -- render GUI
    --
    local camera_gui = state.cameras.camera_gui
    render.set_view(camera_gui.view)
    render.set_projection(camera_gui.proj)

    render.enable_state(render.STATE_STENCIL_TEST)
    render.draw(predicates.gui, camera_gui.frustum)
    render.draw(predicates.debug_text, camera_gui.frustum)
    render.disable_state(render.STATE_STENCIL_TEST)
    render.disable_state(render.STATE_BLEND)
end

function on_message(self, message_id, message)
    local state = self.state
    local camera = state.main_camera
    if message_id == MSG_CLEAR_COLOR then
        update_clear_color(state, message.color)
    elseif message_id == MSG_WINDOW_RESIZED then
        update_state(state)
    elseif message_id == MSG_SET_VIEW_PROJ then
        camera.view = message.view
        self.camera_projection = message.projection or vmath.matrix4()
        update_camera(camera, state)
    elseif message_id == MSG_SET_CAMERA_PROJ then
        camera.projection_fn = function() return self.camera_projection end
    elseif message_id == MSG_USE_STRETCH_PROJ then
        init_camera(camera, get_stretch_projection, message.near, message.far)
        update_camera(camera, state)
    elseif message_id == MSG_USE_FIXED_PROJ then
        init_camera(camera, get_fixed_projection, message.near, message.far, message.zoom)
        update_camera(camera, state)
    elseif message_id == MSG_USE_FIXED_FIT_PROJ then
        init_camera(camera, get_fixed_fit_projection, message.near, message.far)
        update_camera(camera, state)
    end
end

local num_lights = vmath.vector4()
update_constants = function(constants)

    local n = lighting_state.get_num_lights()
    num_lights.x, num_lights.y, num_lights.z, num_lights.w = n, n, n, n
    constants.num_lights = num_lights

    local light_position, light_radii, light_color = lighting_state.get_lights()
    constants.light_position = light_position
    constants.light_radii = light_radii
    constants.light_color = light_color
end